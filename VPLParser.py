# Generated from VPL.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\32")
        buf.write("\u0085\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\3\2\3\2\3\2\3\2\5\2\31\n\2\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\5\3\5\3\5")
        buf.write("\3\5\5\5*\n\5\3\6\3\6\3\6\3\6\3\6\5\6\61\n\6\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\5\7G\n\7\3\b\3\b\3\b\3\b\3\b\5\bN\n\b")
        buf.write("\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3")
        buf.write("\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3")
        buf.write("\t\5\ty\n\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\5\n\u0083")
        buf.write("\n\n\3\n\2\2\13\2\4\6\b\n\f\16\20\22\2\2\2\u008a\2\30")
        buf.write("\3\2\2\2\4\32\3\2\2\2\6!\3\2\2\2\b)\3\2\2\2\n\60\3\2\2")
        buf.write("\2\fF\3\2\2\2\16M\3\2\2\2\20x\3\2\2\2\22\u0082\3\2\2\2")
        buf.write("\24\25\5\4\3\2\25\26\5\2\2\2\26\31\3\2\2\2\27\31\7\2\2")
        buf.write("\3\30\24\3\2\2\2\30\27\3\2\2\2\31\3\3\2\2\2\32\33\7\n")
        buf.write("\2\2\33\34\7\30\2\2\34\35\5\6\4\2\35\36\5\n\6\2\36\37")
        buf.write("\5\f\7\2\37 \7\13\2\2 \5\3\2\2\2!\"\7\3\2\2\"#\5\b\5\2")
        buf.write("#$\7\4\2\2$\7\3\2\2\2%*\7\30\2\2&\'\7\30\2\2\'(\7\5\2")
        buf.write("\2(*\5\b\5\2)%\3\2\2\2)&\3\2\2\2*\t\3\2\2\2+,\7\f\2\2")
        buf.write(",-\5\b\5\2-.\7\6\2\2.\61\3\2\2\2/\61\3\2\2\2\60+\3\2\2")
        buf.write("\2\60/\3\2\2\2\61\13\3\2\2\2\62\63\7\r\2\2\63\64\5\22")
        buf.write("\n\2\64\65\7\16\2\2\65\66\5\f\7\2\66\67\7\17\2\2\678\5")
        buf.write("\16\b\28G\3\2\2\29:\7\21\2\2:;\5\22\n\2;<\7\22\2\2<=\5")
        buf.write("\f\7\2=>\7\20\2\2>?\5\16\b\2?G\3\2\2\2@A\7\30\2\2AB\7")
        buf.write("\7\2\2BC\5\20\t\2CD\5\16\b\2DG\3\2\2\2EG\3\2\2\2F\62\3")
        buf.write("\2\2\2F9\3\2\2\2F@\3\2\2\2FE\3\2\2\2G\r\3\2\2\2HI\7\6")
        buf.write("\2\2IJ\5\f\7\2JK\5\16\b\2KN\3\2\2\2LN\3\2\2\2MH\3\2\2")
        buf.write("\2ML\3\2\2\2N\17\3\2\2\2OP\7\23\2\2PQ\7\3\2\2QR\5\20\t")
        buf.write("\2RS\7\5\2\2ST\5\20\t\2TU\7\4\2\2Uy\3\2\2\2VW\7\24\2\2")
        buf.write("WX\7\3\2\2XY\5\20\t\2YZ\7\5\2\2Z[\5\20\t\2[\\\7\4\2\2")
        buf.write("\\y\3\2\2\2]^\7\25\2\2^_\7\3\2\2_`\5\20\t\2`a\7\5\2\2")
        buf.write("ab\5\20\t\2bc\7\4\2\2cy\3\2\2\2de\7\26\2\2ef\7\3\2\2f")
        buf.write("g\5\20\t\2gh\7\5\2\2hi\5\20\t\2ij\7\4\2\2jy\3\2\2\2kl")
        buf.write("\7\27\2\2lm\7\3\2\2mn\5\20\t\2no\7\5\2\2op\5\20\t\2pq")
        buf.write("\7\4\2\2qy\3\2\2\2rs\7\3\2\2st\5\20\t\2tu\7\4\2\2uy\3")
        buf.write("\2\2\2vy\7\30\2\2wy\7\31\2\2xO\3\2\2\2xV\3\2\2\2x]\3\2")
        buf.write("\2\2xd\3\2\2\2xk\3\2\2\2xr\3\2\2\2xv\3\2\2\2xw\3\2\2\2")
        buf.write("y\21\3\2\2\2z{\5\20\t\2{|\7\b\2\2|}\7\31\2\2}\u0083\3")
        buf.write("\2\2\2~\177\5\20\t\2\177\u0080\7\t\2\2\u0080\u0081\7\31")
        buf.write("\2\2\u0081\u0083\3\2\2\2\u0082z\3\2\2\2\u0082~\3\2\2\2")
        buf.write("\u0083\23\3\2\2\2\t\30)\60FMx\u0082")
        return buf.getvalue()


class VPLParser ( Parser ):

    grammarFileName = "VPL.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'('", "')'", "','", "';'", "'='", "'<'", 
                     "'>='", "'func'", "'end'", "'var'", "'if'", "'then'", 
                     "'endif'", "'endwhile'", "'while'", "'do'", "'add'", 
                     "'minus'", "'mult'", "'div'", "'min'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "FUNC", "END", "VAR", "IF", "THEN", "ENDIF", "ENDWHILE", 
                      "WHILE", "DO", "ADD", "MINUS", "MULT", "DIV", "MIN", 
                      "IDENT", "NUM", "WS" ]

    RULE_program = 0
    RULE_function_declaration = 1
    RULE_parameter = 2
    RULE_name = 3
    RULE_variable_declaration = 4
    RULE_statement = 5
    RULE_nest_statement = 6
    RULE_expression = 7
    RULE_compare = 8

    ruleNames =  [ "program", "function_declaration", "parameter", "name", 
                   "variable_declaration", "statement", "nest_statement", 
                   "expression", "compare" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    FUNC=8
    END=9
    VAR=10
    IF=11
    THEN=12
    ENDIF=13
    ENDWHILE=14
    WHILE=15
    DO=16
    ADD=17
    MINUS=18
    MULT=19
    DIV=20
    MIN=21
    IDENT=22
    NUM=23
    WS=24

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_declaration(self):
            return self.getTypedRuleContext(VPLParser.Function_declarationContext,0)


        def program(self):
            return self.getTypedRuleContext(VPLParser.ProgramContext,0)


        def EOF(self):
            return self.getToken(VPLParser.EOF, 0)

        def getRuleIndex(self):
            return VPLParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = VPLParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.state = 22
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VPLParser.FUNC]:
                self.enterOuterAlt(localctx, 1)
                self.state = 18
                self.function_declaration()
                self.state = 19
                self.program()
                pass
            elif token in [VPLParser.EOF]:
                self.enterOuterAlt(localctx, 2)
                self.state = 21
                self.match(VPLParser.EOF)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNC(self):
            return self.getToken(VPLParser.FUNC, 0)

        def IDENT(self):
            return self.getToken(VPLParser.IDENT, 0)

        def parameter(self):
            return self.getTypedRuleContext(VPLParser.ParameterContext,0)


        def variable_declaration(self):
            return self.getTypedRuleContext(VPLParser.Variable_declarationContext,0)


        def statement(self):
            return self.getTypedRuleContext(VPLParser.StatementContext,0)


        def END(self):
            return self.getToken(VPLParser.END, 0)

        def getRuleIndex(self):
            return VPLParser.RULE_function_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_declaration" ):
                listener.enterFunction_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_declaration" ):
                listener.exitFunction_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_declaration" ):
                return visitor.visitFunction_declaration(self)
            else:
                return visitor.visitChildren(self)




    def function_declaration(self):

        localctx = VPLParser.Function_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_function_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 24
            self.match(VPLParser.FUNC)
            self.state = 25
            self.match(VPLParser.IDENT)
            self.state = 26
            self.parameter()
            self.state = 27
            self.variable_declaration()
            self.state = 28
            self.statement()
            self.state = 29
            self.match(VPLParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(VPLParser.NameContext,0)


        def getRuleIndex(self):
            return VPLParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = VPLParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 31
            self.match(VPLParser.T__0)
            self.state = 32
            self.name()
            self.state = 33
            self.match(VPLParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return VPLParser.RULE_name

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class MultParameterNameContext(NameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.NameContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENT(self):
            return self.getToken(VPLParser.IDENT, 0)
        def name(self):
            return self.getTypedRuleContext(VPLParser.NameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultParameterName" ):
                listener.enterMultParameterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultParameterName" ):
                listener.exitMultParameterName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultParameterName" ):
                return visitor.visitMultParameterName(self)
            else:
                return visitor.visitChildren(self)


    class ParameterNameContext(NameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.NameContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENT(self):
            return self.getToken(VPLParser.IDENT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterName" ):
                listener.enterParameterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterName" ):
                listener.exitParameterName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterName" ):
                return visitor.visitParameterName(self)
            else:
                return visitor.visitChildren(self)



    def name(self):

        localctx = VPLParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_name)
        try:
            self.state = 39
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                localctx = VPLParser.ParameterNameContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 35
                self.match(VPLParser.IDENT)
                pass

            elif la_ == 2:
                localctx = VPLParser.MultParameterNameContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 36
                self.match(VPLParser.IDENT)
                self.state = 37
                self.match(VPLParser.T__2)
                self.state = 38
                self.name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(VPLParser.VAR, 0)

        def name(self):
            return self.getTypedRuleContext(VPLParser.NameContext,0)


        def getRuleIndex(self):
            return VPLParser.RULE_variable_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_declaration" ):
                listener.enterVariable_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_declaration" ):
                listener.exitVariable_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_declaration" ):
                return visitor.visitVariable_declaration(self)
            else:
                return visitor.visitChildren(self)




    def variable_declaration(self):

        localctx = VPLParser.Variable_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_variable_declaration)
        try:
            self.state = 46
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VPLParser.VAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 41
                self.match(VPLParser.VAR)
                self.state = 42
                self.name()
                self.state = 43
                self.match(VPLParser.T__3)
                pass
            elif token in [VPLParser.END, VPLParser.IF, VPLParser.WHILE, VPLParser.IDENT]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return VPLParser.RULE_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class WhileloopContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WHILE(self):
            return self.getToken(VPLParser.WHILE, 0)
        def compare(self):
            return self.getTypedRuleContext(VPLParser.CompareContext,0)

        def DO(self):
            return self.getToken(VPLParser.DO, 0)
        def statement(self):
            return self.getTypedRuleContext(VPLParser.StatementContext,0)

        def ENDWHILE(self):
            return self.getToken(VPLParser.ENDWHILE, 0)
        def nest_statement(self):
            return self.getTypedRuleContext(VPLParser.Nest_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileloop" ):
                listener.enterWhileloop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileloop" ):
                listener.exitWhileloop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileloop" ):
                return visitor.visitWhileloop(self)
            else:
                return visitor.visitChildren(self)


    class ConditionContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IF(self):
            return self.getToken(VPLParser.IF, 0)
        def compare(self):
            return self.getTypedRuleContext(VPLParser.CompareContext,0)

        def THEN(self):
            return self.getToken(VPLParser.THEN, 0)
        def statement(self):
            return self.getTypedRuleContext(VPLParser.StatementContext,0)

        def ENDIF(self):
            return self.getToken(VPLParser.ENDIF, 0)
        def nest_statement(self):
            return self.getTypedRuleContext(VPLParser.Nest_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)


    class NoneStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNoneStatement" ):
                listener.enterNoneStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNoneStatement" ):
                listener.exitNoneStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNoneStatement" ):
                return visitor.visitNoneStatement(self)
            else:
                return visitor.visitChildren(self)


    class AssignContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENT(self):
            return self.getToken(VPLParser.IDENT, 0)
        def expression(self):
            return self.getTypedRuleContext(VPLParser.ExpressionContext,0)

        def nest_statement(self):
            return self.getTypedRuleContext(VPLParser.Nest_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign" ):
                listener.enterAssign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign" ):
                listener.exitAssign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssign" ):
                return visitor.visitAssign(self)
            else:
                return visitor.visitChildren(self)



    def statement(self):

        localctx = VPLParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_statement)
        try:
            self.state = 68
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VPLParser.IF]:
                localctx = VPLParser.ConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 48
                self.match(VPLParser.IF)
                self.state = 49
                self.compare()
                self.state = 50
                self.match(VPLParser.THEN)
                self.state = 51
                self.statement()
                self.state = 52
                self.match(VPLParser.ENDIF)
                self.state = 53
                self.nest_statement()
                pass
            elif token in [VPLParser.WHILE]:
                localctx = VPLParser.WhileloopContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 55
                self.match(VPLParser.WHILE)
                self.state = 56
                self.compare()
                self.state = 57
                self.match(VPLParser.DO)
                self.state = 58
                self.statement()
                self.state = 59
                self.match(VPLParser.ENDWHILE)
                self.state = 60
                self.nest_statement()
                pass
            elif token in [VPLParser.IDENT]:
                localctx = VPLParser.AssignContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 62
                self.match(VPLParser.IDENT)
                self.state = 63
                self.match(VPLParser.T__4)
                self.state = 64
                self.expression()
                self.state = 65
                self.nest_statement()
                pass
            elif token in [VPLParser.T__3, VPLParser.END, VPLParser.ENDIF, VPLParser.ENDWHILE]:
                localctx = VPLParser.NoneStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 4)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Nest_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(VPLParser.StatementContext,0)


        def nest_statement(self):
            return self.getTypedRuleContext(VPLParser.Nest_statementContext,0)


        def getRuleIndex(self):
            return VPLParser.RULE_nest_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNest_statement" ):
                listener.enterNest_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNest_statement" ):
                listener.exitNest_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNest_statement" ):
                return visitor.visitNest_statement(self)
            else:
                return visitor.visitChildren(self)




    def nest_statement(self):

        localctx = VPLParser.Nest_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_nest_statement)
        try:
            self.state = 75
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 70
                self.match(VPLParser.T__3)
                self.state = 71
                self.statement()
                self.state = 72
                self.nest_statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return VPLParser.RULE_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IdenetExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENT(self):
            return self.getToken(VPLParser.IDENT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdenetExpression" ):
                listener.enterIdenetExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdenetExpression" ):
                listener.exitIdenetExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdenetExpression" ):
                return visitor.visitIdenetExpression(self)
            else:
                return visitor.visitChildren(self)


    class MinExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MIN(self):
            return self.getToken(VPLParser.MIN, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VPLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(VPLParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinExpression" ):
                listener.enterMinExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinExpression" ):
                listener.exitMinExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinExpression" ):
                return visitor.visitMinExpression(self)
            else:
                return visitor.visitChildren(self)


    class MinusExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MINUS(self):
            return self.getToken(VPLParser.MINUS, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VPLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(VPLParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinusExpression" ):
                listener.enterMinusExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinusExpression" ):
                listener.exitMinusExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinusExpression" ):
                return visitor.visitMinusExpression(self)
            else:
                return visitor.visitChildren(self)


    class AddExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ADD(self):
            return self.getToken(VPLParser.ADD, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VPLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(VPLParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddExpression" ):
                listener.enterAddExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddExpression" ):
                listener.exitAddExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddExpression" ):
                return visitor.visitAddExpression(self)
            else:
                return visitor.visitChildren(self)


    class NumExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUM(self):
            return self.getToken(VPLParser.NUM, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumExpression" ):
                listener.enterNumExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumExpression" ):
                listener.exitNumExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumExpression" ):
                return visitor.visitNumExpression(self)
            else:
                return visitor.visitChildren(self)


    class MultExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MULT(self):
            return self.getToken(VPLParser.MULT, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VPLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(VPLParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultExpression" ):
                listener.enterMultExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultExpression" ):
                listener.exitMultExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultExpression" ):
                return visitor.visitMultExpression(self)
            else:
                return visitor.visitChildren(self)


    class ParenthesisExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(VPLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesisExpression" ):
                listener.enterParenthesisExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesisExpression" ):
                listener.exitParenthesisExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesisExpression" ):
                return visitor.visitParenthesisExpression(self)
            else:
                return visitor.visitChildren(self)


    class DivExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DIV(self):
            return self.getToken(VPLParser.DIV, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VPLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(VPLParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDivExpression" ):
                listener.enterDivExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDivExpression" ):
                listener.exitDivExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDivExpression" ):
                return visitor.visitDivExpression(self)
            else:
                return visitor.visitChildren(self)



    def expression(self):

        localctx = VPLParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_expression)
        try:
            self.state = 118
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VPLParser.ADD]:
                localctx = VPLParser.AddExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 77
                self.match(VPLParser.ADD)
                self.state = 78
                self.match(VPLParser.T__0)
                self.state = 79
                self.expression()
                self.state = 80
                self.match(VPLParser.T__2)
                self.state = 81
                self.expression()
                self.state = 82
                self.match(VPLParser.T__1)
                pass
            elif token in [VPLParser.MINUS]:
                localctx = VPLParser.MinusExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 84
                self.match(VPLParser.MINUS)
                self.state = 85
                self.match(VPLParser.T__0)
                self.state = 86
                self.expression()
                self.state = 87
                self.match(VPLParser.T__2)
                self.state = 88
                self.expression()
                self.state = 89
                self.match(VPLParser.T__1)
                pass
            elif token in [VPLParser.MULT]:
                localctx = VPLParser.MultExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 91
                self.match(VPLParser.MULT)
                self.state = 92
                self.match(VPLParser.T__0)
                self.state = 93
                self.expression()
                self.state = 94
                self.match(VPLParser.T__2)
                self.state = 95
                self.expression()
                self.state = 96
                self.match(VPLParser.T__1)
                pass
            elif token in [VPLParser.DIV]:
                localctx = VPLParser.DivExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 98
                self.match(VPLParser.DIV)
                self.state = 99
                self.match(VPLParser.T__0)
                self.state = 100
                self.expression()
                self.state = 101
                self.match(VPLParser.T__2)
                self.state = 102
                self.expression()
                self.state = 103
                self.match(VPLParser.T__1)
                pass
            elif token in [VPLParser.MIN]:
                localctx = VPLParser.MinExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 105
                self.match(VPLParser.MIN)
                self.state = 106
                self.match(VPLParser.T__0)
                self.state = 107
                self.expression()
                self.state = 108
                self.match(VPLParser.T__2)
                self.state = 109
                self.expression()
                self.state = 110
                self.match(VPLParser.T__1)
                pass
            elif token in [VPLParser.T__0]:
                localctx = VPLParser.ParenthesisExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 112
                self.match(VPLParser.T__0)
                self.state = 113
                self.expression()
                self.state = 114
                self.match(VPLParser.T__1)
                pass
            elif token in [VPLParser.IDENT]:
                localctx = VPLParser.IdenetExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 116
                self.match(VPLParser.IDENT)
                pass
            elif token in [VPLParser.NUM]:
                localctx = VPLParser.NumExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 117
                self.match(VPLParser.NUM)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompareContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return VPLParser.RULE_compare

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LessThanContext(CompareContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.CompareContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(VPLParser.ExpressionContext,0)

        def NUM(self):
            return self.getToken(VPLParser.NUM, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLessThan" ):
                listener.enterLessThan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLessThan" ):
                listener.exitLessThan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLessThan" ):
                return visitor.visitLessThan(self)
            else:
                return visitor.visitChildren(self)


    class LargeThanContext(CompareContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a VPLParser.CompareContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(VPLParser.ExpressionContext,0)

        def NUM(self):
            return self.getToken(VPLParser.NUM, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLargeThan" ):
                listener.enterLargeThan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLargeThan" ):
                listener.exitLargeThan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLargeThan" ):
                return visitor.visitLargeThan(self)
            else:
                return visitor.visitChildren(self)



    def compare(self):

        localctx = VPLParser.CompareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_compare)
        try:
            self.state = 128
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                localctx = VPLParser.LessThanContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 120
                self.expression()
                self.state = 121
                self.match(VPLParser.T__5)
                self.state = 122
                self.match(VPLParser.NUM)
                pass

            elif la_ == 2:
                localctx = VPLParser.LargeThanContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 124
                self.expression()
                self.state = 125
                self.match(VPLParser.T__6)
                self.state = 126
                self.match(VPLParser.NUM)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





